<!doctype html>
<html>

<head>
    <link rel="stylesheet" href="node_modules/@chrisoakman/chessboardjs/dist/chessboard-1.0.0.min.css"
        crossorigin="anonymous">
    <style>
        #boards {
            display: flex;
        }
    </style>
</head>

<body>

    <div class="stepper">
        <select id="opening"></select>

        <div id="moves"> </div>

        <div id="boards"></div>
    </div>

    <script src="node_modules/jquery/dist/jquery.min.js"></script>
    <script src="node_modules/@chrisoakman/chessboardjs/dist/chessboard-1.0.0.min.js"></script>
    <script>
        player = new class {

            database = [
                { appliesTo: 'white', name: 'Scholars Mate (1)', moves: ['e2-e4', 'e7-e5', 'f1-c4', 'd1-f3', 'f3-f7'] },

                { appliesTo: 'white', name: 'Scholars Mate (2)', moves: ['e2-e4', 'e7-e5', 'f1-c4', 'd1-h5', 'h5-f7'] },
                { appliesTo: 'white', name: 'Tennison Gambit (1)', moves: 'e2-e4 d7-d5 g1-f3 d5-e4 f3-e5 f7-f6 d1-h5 g7-g6 f1-c4 g6-h5 c4-f7'.split(' ') },
                { appliesTo: 'white', name: 'Tennison Gambit (2)', moves: 'e2-e4 d7-d5 g1-f3 d5-e4 f3-g5 g8-f6 d2-d3 e4-d3 f1-d3 h7-h6 g5-f7 e8-f7 d3-g6 f7-g6 d1-d8'.split(' ') },
                { appliesTo: 'white', name: 'Mortimer Trap', moves: 'e2-e4 e7-e5 g1-f3 b8-c6 f1-b5 g8-f6 d2-d3 c6-e7 f3-e5 c7-c6 e5-c4 c6-b5 c4-d6'.split(' ') },

                //https://www.chess.com/openings/Italian-Game-Fried-Liver-Attack
                { appliesTo: 'white', name: 'Italian Game - Fried Liver Attack', moves: 'e2-e4 e7-e5 g1-f3 b8-c6 f1-c4 g8-f6 f3-g5 d7-d5 e4-d5 f6-d5 g5-f7 d8-e7 f7-h8'.split(' ') },

                // https://www.youtube.com/watch?v=6ACqk117Q7U&list=PL90OzHiSE_mQcVlOHQ0_niB29icDmDipY&index=2
                { appliesTo: 'white', name: 'Italian Game (1)', moves: 'e2-e4 e7-e5 g1-f3 b8-c6 f1-c4 d7-d6 b1-c3 g8-f6 f3-g5 h7-h6 g5-f7 d8-e7 f7-h8'.split(' ') },
                { appliesTo: 'white', name: 'Italian Game (2)', moves: 'e2-e4 e7-e5 g1-f3 b8-c6 f1-c4 d7-d6 b1-c3 c8-g4 h2-h3 g4-h5 f3-e5 c6-e5 d1-h5 e5-c4 h5-b5 d8-d7 b5-c4'.split(' ') },
                { appliesTo: 'white', name: 'Italian Game - LÃ©gal Trap', moves: 'e2-e4 e7-e5 g1-f3 b8-c6 f1-c4 d7-d6 b1-c3 c8-g4 h2-h3 g4-h5 f3-e5 h5-d1 c4-f7 e8-e7 c3-d5 d5-e7'.split(' ') },
                { appliesTo: 'black', name: 'Italian Game - Blackburne Shilling Gambit', moves: 'e2-e4 e7-e5 g1-f3 b8-c6 f1-c4 c6-d4 f3-e5 d8-g5 e5-f7 g5-g2 f7-h8 g2-h1 c4-f1 h1-e4 f1-e2 d4-c2 e1-f1 e4-h1 h1-f1'.split(' ') },
                { appliesTo: 'white', name: 'Italian Game - Blackburne Shilling Gambit Defense', moves: 'e2-e4 e7-e5 g1-f3 b8-c6 f1-c4 c6-d4 e1-g1&h1-f1 d4-f3 d1-f3 g8-f6 d2-d4 e5-d4 e4-e5 d7-d5 e5-f6 d5-c4 c1-g5 g7-g6 f1-e1 c8-e6 e1-e6 f7-e6 f6-f7 f7-e8'.split(' ') },
                { appliesTo: 'white', name: 'Italian Game - Rousseau Gambit', moves: 'e2-e4 e7-e5 g1-f3 b8-c6 f1-c4 f7-f5 e4-f5 e5-e4 f3-d4 c6-d4 d1-h5 g7-g6 f5-g6 g8-f6 g6-g7 f6-h5 g7-h8 d4-c2 e1-d1 c2-a1 h8-h7 h5-f6 h7-f7 f7-e8'.split(' ') },
                { appliesTo: 'white', name: 'Italian Game - Giuoco Piano', moves: 'e2-e4 e7-e5 g1-f3 b8-c6 f1-c4 f8-c5 d2-d3 g8-f6 b1-c3 e8-g8 h8-f8 c1-g5 d7-d6 c3-d5 h7-h6 d5-f6 g7-f6 g5-h6 f8-e8 f3-h4 f6-f5 c4-f7 g8-f7 d1-h5 f7-g8 h5-g6 g8-h8 g6-g7 g7-h8'.split(' ') },

                { appliesTo: 'black', name: 'Scandinavian Defense (1)', moves: 'e2-e4 d7-d5 b1-c3 d5-d4 c3-d5 e7-e5 * c7-c6 * c6-d5'.split(' ') },

                // http://youtube.com/watch?v=sKoBj-kL0hg&list=PL90OzHiSE_mQcVlOHQ0_niB29icDmDipY&index=11
                { appliesTo: 'black', name: 'Scandinavian Defense (2)', moves: 'e2-e4 d7-d5 e4-d5 g8-f6 c2-c4 e7-e6 d5-e6 c8-e6 d2-d4 f8-b4 b1-c3 f6-e4 c1-d2 d8-d4 g1-f3 d4-f2'.split(' ') },

                //https://www.youtube.com/watch?v=jEGFEC7qYkM
                { appliesTo: 'black', name: 'Scandinavian Defense (3)', moves: 'e2-e4 d7-d5 e4-d5 g8-f6 b1-c3 f6-d5 c3-d5 d8-d5 d2-d4 b8-c6 g1-f3 c8-g4 f1-e2 e8-c8&a8-d8 c2-c3 e7-e5 d4-e5 d5-e4 d1-b3 c6-e5 f3-e5 e4-e2'.split(' ') },

                //https://www.youtube.com/watch?v=bmsjE0ZYUoA&list=PL90OzHiSE_mQcVlOHQ0_niB29icDmDipY
                { appliesTo: 'white', name: 'Bishops Opening Trap (1)', moves: 'e2-e4 e7-e5 f1-c4 g8-f6 b1-c3 f8-c5 d2-d3 d7-d6 f2-f4 f6-g4 f4-f5 g4-f2 d1-h5 e8-g8&h8-f8 c1-g5 d8-e8 c3-d5 f2-h1 d5-f6 g7-f6 g5-f6 * h5-g5 * g5-g7 g7-g8'.split(' ') },
                { appliesTo: 'black', name: 'Bishops Opening Trap (2)', moves: 'e2-e4 e7-e5 f1-c4 g8-f6 d2-d4 e5-d4 e4-e5 d7-d5 c4-b3 f6-e4 g1-e2 f8-c5 f2-f3 d8-h4 g2-g3 d4-d3 g3-h4 c5-f2 e1-f1 c8-h3'.split(' ') },

                // https://www.youtube.com/watch?v=Uno3DLxDufI&list=PL90OzHiSE_mQcVlOHQ0_niB29icDmDipY&index=14
                { appliesTo: 'black', name: 'Soller Gambit', moves: 'd2-d4 e7-e5 d4-e5 f7-f6 e5-f6 g8-f6 g1-f3 f8-c5 c1-g5 f6-e4 g5-d8 c5-f2 f2-e1'.split(' ') },
            ];

            selection = (localStorage.selection || '').split(',').filter(Boolean);
            get Selection() { return this.selection; }
            set Selection(selection) { localStorage.selection = this.selection = selection; this.draw(); }

            opening = undefined;
            get Opening() { return this.database[this.opening] }

            get turn() { return ['white', 'black'][this.selection.length % 2]; }

            constructor() {
                document.addEventListener('keydown', event => { if (event.key === 'ArrowLeft') this.back(); });
                $('#opening')
                    .html('<option>--opening--</option>' + this.database.map((o, i) => `<option value=${i}>${o.appliesTo} : ${o.name}</option>`).join(''))
                    .on('change', ({ target }) => {
                        this.opening = target.value;
                        if (this.Opening) {
                            this.Selection = [this.Opening.appliesTo];
                            this.draw();
                        }
                    });
                this.draw();
            }

            back() {
                this.Selection = this.selection.slice(0, this.selection.length - 1);
            }

            next(choice) {
                if (choice !== this.selection.at(-1))
                    this.Selection = [...this.selection, choice];
            }

            async draw() {
                $('#boards').html('');
                $('#moves').html(this.selection.map(move => `<a href="javascript:void(0)">${move}</a>`).join(' / '))
                $('#moves').children().each((index, child) => {
                    $(child).on('click', () => {
                        this.Selection = this.selection.slice(0, index);
                        this.draw();
                    });
                });

                const moves = [...this.selection];
                const orientation = moves.shift();
                const openings = this.Opening && [this.Opening]
                    || !orientation && ['black', 'white'].map(appliesTo => ({ appliesTo, moves: [] }))
                    || this.database
                        .filter(opening => !orientation || opening.appliesTo.includes(orientation))
                        .filter(opening => moves.every((move, index) => opening.moves[index] == move));

                // show the next move for every opening that matches the line we have played so far
                for (var opening of openings) {

                    // avoid repeating two openings that 
                    const common = openings.filter(o => o.moves[moves.length] == opening.moves[moves.length]);
                    const titles = [...new Set(common.map(o => o.name))];
                    const title = titles.join(', ');
                    const index = common.indexOf(opening);
                    const orientation = opening.appliesTo;

                    if (index > 0 && opening.moves.length) continue;

                    // html
                    $('#boards').append(`<div style="width: 400px;"> <div class="board"></div> <div class="title"> </div> </div> `);

                    // $board
                    const el = $('#boards .board').last();
                    var board = Chessboard(el, { position: 'start', moveSpeed: 0 });

                    // set orientation
                    board.orientation(orientation);

                    const domove = (move) => {
                        for (const m of move.split('&'))
                            board.move(m)
                    };

                    // play the moves so far ( for each opening that begins with the same moves as the user's selection )
                    for (const move of moves) domove(move);

                    // show the next move for the opening
                    const final = opening.moves.length === moves.length && 'red';
                    const secondLast = opening.moves.length === moves.length + 1 && 'green';
                    const nextMove = opening.moves.length === 0 && orientation
                        || opening.moves[moves.length]
                        || opening.moves[moves.length - 1];

                    $('#boards .title').last().html(`${title} (${nextMove})`);

                    const position = board.position();
                    if (nextMove == '*') {
                        const method = 2;
                        if (method == 2) {  /** Method 2 : remove all pieces of the current turn */
                            for (const [k, v] of [...Object.entries(position)])
                                if (!v.startsWith(this.turn.at(0))) {
                                    delete position[k];
                                }
                        } else {            /** Method 1 ; remove all untouched pieces */
                            const touched = this.selection.reduce((squares, move) => {
                                for (const _move of move.split('&'))
                                    for (const square of _move.split('-'))
                                        squares.add(square);
                                return squares;
                            }, new Set);
                            for (const [k, v] of Object.entries(position)) {
                                if (!touched.has(k))
                                    delete position[k];
                            }
                        }
                    }
                    board.destroy();
                    board = Chessboard(el, {
                        position,
                        draggable: true,
                        onDrop: (source, target, piece, newPos, oldPos, orientation) => {
                            if (source == target) this.next(nextMove);
                            else if (target !== 'offboard') {
                                const move = [source, target].join('-');
                                if (!final) {
                                    this.database.push(opening = JSON.parse(JSON.stringify(opening)));
                                    opening.moves.splice(this.selection.length - 1);
                                    opening.title += ' ( clone )';
                                }
                                opening.moves = [...this.selection.slice(1), ...(final ? [] : [nextMove]), move];
                                if (!final) this.next(nextMove);
                                this.next(move);
                                navigator.clipboard.writeText(opening.moves.join(' '));
                            }
                        }
                    });
                    board.orientation(orientation);

                    if (nextMove) {
                        domove(nextMove);
                        el.on('click', () => this.next(nextMove));
                    }

                    $('#moves a').eq(opening.moves.length).css('color', 'red');
                    $('#moves a').eq(opening.moves.length - 1).css('color', 'green');
                }
            }
        }
    </script>
</body>

</html>